/**===========================================================================
 * @file trng.c
 *
 * @brief This file defines the TRNG initialization and access API's.
 * All the TRNG data generation and access interface are defined here
 *
 * @author ravikiran@design-shift.com
 *
 ============================================================================
 *
 * Copyright © Design SHIFT, 2017-2018
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright.
 *     * Neither the name of the [ORWL] nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY DESIGN SHIFT ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL DESIGN SHIFT BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ============================================================================
 *
 */

/* Local includes */
#include <trng.h>

/* debug and log message header */
#include <debug.h>

/**
 * @brief function initializes the TRNG.
 *
 * This function initializes TRNG by writing to TRNG module registers.
 * This is a private function which is called internally to enable TRNG
 * whenever there is a request from application to generate a Random Number.
 *
 * @return None
 */
static void prvTrngInit( void );

/**
 * @brief This function reads true random number from the system
 *
 * @param ulpRandNumBuf output buffer to place random numbers generated
 * @param length number of bytes of random number requested by user
 * 			It is preferred to have read length multiple
 * 			of 4Bytes (a word). Otherwise length will be truncated to the
 * 			nearest (lower) integer
 *
 * @return error code on any error
 * 			Zero (0) on success.
 */
static uint32_t prvTrngRead( uint32_t *pulRandNumBuf, uint32_t ulReadLen );

/*****************************************************************************/
/* TRNG initialization */
static void prvTrngInit( void ) {
	volatile mml_trng_regs_t *reg_trng =
			(volatile mml_trng_regs_t*) MML_TRNG_IOBASE;

	/* Enable TRNG even if done automatically and Clear word status */
	reg_trng->trngcr |= (MML_TRNGCN_RNG_EN_MASK | MML_TRNGCN_RNG_BS_MASK
			| MML_TRNGCN_RNG_ISC_MASK);

	debugPRINT_TRNG("Initialized TRNG\n");
}

/*****************************************************************************/

/* TRNG read function */
static uint32_t prvTrngRead( uint32_t *pulRandNumBuf, uint32_t ulReadLen ) {

	/* RNG read loop count */
	uint32_t ulLoopCount = 0;

	/* dummy TRNG buffer */
	uint32_t ulTempReadBuf;

	/* TRNG IOBASE register as defined by mml layer */
	volatile mml_trng_regs_t *reg_trng =
			(volatile mml_trng_regs_t*) MML_TRNG_IOBASE;

	debugPRINT_TRNG(" Entered TRNG Read \n");

	if (ulReadLen < trngMIN_TRNG_GEN_WORDS || ulReadLen > trngTRNG_SINGLE_SHOT_READ_LEN) {
		debugERROR_PRINT(
				" Minimum %d Bytes generated by TRNG, Max supported Bytes is %d, requested %d bytes\n",
				trngMIN_TRNG_GEN_WORDS, trngTRNG_SINGLE_SHOT_READ_LEN, ulReadLen);
		return COMMON_ERR_OUT_OF_RANGE;
	}

	if (!pulRandNumBuf) {
		debugERROR_PRINT(" TRNG data buffer provided is NULL \n");
		return COMMON_ERR_NULL_PTR;
	}

	/* Enable & Initialize TRNG */
	prvTrngInit();

	if (reg_trng->trngcr & MML_TRNGCN_RNG_I4S_MASK) {
		/* clear the previously generated data, if any */
		for (ulLoopCount = 0; ulLoopCount < ulReadLen; ulLoopCount++) {
			ulTempReadBuf = reg_trng->trngdr;
			debugPRINT_TRNG(" Reading TempBuff contents : ulTempReadBuf[%d] = 0x%x \n",ulLoopCount,ulTempReadBuf);

		}
	}

	/* reset input buffer */
	memset(pulRandNumBuf, 0x00, ulReadLen*sizeof(pulRandNumBuf));

	/* First clear RNG_I4S bit before asking for a new 128bits TRN */
	reg_trng->trngcr |= MML_TRNGCN_RNG_ISC_MASK;
	ulLoopCount = trngMAX_WAIT_TIME;

	/* Only 128bits number is read */
	while (!(reg_trng->trngcr & MML_TRNGCN_RNG_I4S_MASK) && ulLoopCount--)
		;

	/* Check why above loop terminated */
	if (!ulLoopCount && !(reg_trng->trngcr & MML_TRNGCN_RNG_I4S_MASK)) {
		debugERROR_PRINT(
				"Failed to generate the random number trngcr = 0x%x ulLoopCount = %d \n",
				reg_trng->trngcr, ulLoopCount);
		return COMMON_ERR_BAD_STATE;
	} else {
		/* RNG ready to read. Start reading random number */
		for (ulLoopCount = 0; ulLoopCount < ulReadLen; ulLoopCount++) {
			/* user expected to provide buffer which can hold sufficient data */
			ulTempReadBuf = reg_trng->trngdr;
			memcpy(&pulRandNumBuf[ulLoopCount], &ulTempReadBuf, sizeof(reg_trng->trngdr));
			debugPRINT_TRNG("Generated Random number ulpRandNumBuf[%d]= 0x%x\n",
					ulLoopCount, pulRandNumBuf[ulLoopCount]);
		}
	}

	debugPRINT_TRNG(" Leaving TRNG Read \n");
	return NO_ERROR;
}

/*****************************************************************************/

uint32_t ulGenerateRandomNumber( uint32_t *pulRandNumBuf, uint32_t ulNumWords ) {

	/*status byte*/
	uint32_t ulStatus;

	/* read buffer offset tracker */
	uint32_t ulReadOffest;

	/* validate input buffer */
	if (pulRandNumBuf == NULL) {
		return COMMON_ERR_NULL_PTR;
	}

	/* check for minimum number: Never restrict on Max request */
	if (ulNumWords < trngMIN_TRNG_GEN_WORDS) {
		debugPRINT_TRNG(" Requested length must be minimum %d \n",trngMIN_TRNG_GEN_WORDS);
		return COMMON_ERR_OUT_OF_RANGE;
	}

	/* requested number of bytes from TRNG must be multiple of 4 (1 word on ARM-32 bit) */
	if ((ulNumWords % trngMIN_TRNG_GEN_WORDS) != 0) {
		debugPRINT_TRNG(" Invalid length requested %d \n",ulNumWords);
		return COMMON_ERR_INVAL;
	}

	ulReadOffest = 0;
	while (ulNumWords > 0) {

		if(ulNumWords > trngTRNG_SINGLE_SHOT_READ_LEN)
		{
			ulStatus = prvTrngRead(&pulRandNumBuf[ulReadOffest], trngTRNG_SINGLE_SHOT_READ_LEN);
			if(ulStatus == NO_ERROR)
			{
				ulNumWords -= trngTRNG_SINGLE_SHOT_READ_LEN;
				ulReadOffest += trngTRNG_SINGLE_SHOT_READ_LEN;
			}
			else
			{
				debugPRINT_TRNG(" Failed to generated Random number \n");
				return ulStatus;
			}
		}
		else
		{
			ulStatus = prvTrngRead(&pulRandNumBuf[ulReadOffest], ulNumWords);
			if(ulStatus == NO_ERROR)
			{
				ulNumWords = 0;
			}
			else
			{
				debugPRINT_TRNG(" Failed to generated Random number \n");
				return ulStatus;
			}
		}

		if(ulNumWords > 0)
		{
			/* TODO: 32 clock cycle delay before next TRNG read */
		}
	}
	return NO_ERROR;
}
/*****************************************************************************/
